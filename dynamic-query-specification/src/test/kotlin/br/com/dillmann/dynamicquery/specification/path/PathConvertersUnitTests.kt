package br.com.dillmann.dynamicquery.specification.path

import br.com.dillmann.dynamicquery.specification.randomInt
import br.com.dillmann.dynamicquery.specification.randomString
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import jakarta.persistence.criteria.Path
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

/**
 * [PathConverters] unit tests
 */
class PathConvertersUnitTests {

    private val startPoint = mockk<Path<out Any>>()
    private val converter1 = buildMockedConverter(1, true)
    private val converter2 = buildMockedConverter(2, true)

    @BeforeEach
    fun setUp() {
        PathConverters.register(converter1)
        PathConverters.register(converter2)
    }

    @AfterEach
    fun tearDown() {
        PathConverters.deregister(converter1)
        PathConverters.deregister(converter2)
    }

    @Test
    fun `register should include the provided converter in the internal list of available converters`() {
        // scenario
        val converter = buildMockedConverter(Int.MIN_VALUE, true)

        try {
            // execution
            PathConverters.register(converter)

            // validation
            PathConverters.convert(randomString, startPoint)
            verify { converter.supports(any(), any()) }
            verify { converter.convert(any(), any()) }
        } finally {
            // cleanup
            PathConverters.deregister(converter)
        }
    }

    @Test
    fun `deregister should remove the provided converter in the internal list of available converters`() {
        // scenario
        val converter = buildMockedConverter(Int.MIN_VALUE)
        PathConverters.register(converter)

        // execution
        PathConverters.deregister(converter)

        // validation
        PathConverters.convert(randomString, startPoint)
        verify(exactly = 0) { converter.supports(any(), any()) }
        verify(exactly = 0) { converter.convert(any(), any()) }
    }

    @Test
    fun `convert should return the provided path unchanged when no converter supports the conversion`() {
        // scenario
        val input = randomString
        every { converter1.supports(any(), any()) } returns false
        every { converter2.supports(any(), any()) } returns false
        every { converter1.convert(any(), any()) } returns "$randomString-$randomInt"
        every { converter2.convert(any(), any()) } returns "$randomString-$randomInt"

        // execution
        val result = PathConverters.convert(input, startPoint)

        // validation
        assertEquals(input, result)
    }

    @Test
    fun `convert should return the provided path unchanged when no converter is available in the internal state`() {
        // scenario
        val input = randomString
        PathConverters.deregister(converter1)
        PathConverters.deregister(converter2)

        // execution
        val result = PathConverters.convert(input, startPoint)

        // validation
        assertEquals(input, result)
    }

    @Test
    fun `convert should return the value generated by the first converter that supports the conversion scenario`() {
        // scenario
        val firstResponse = randomString
        val secondResponse = randomString
        every { converter1.convert(any(), any()) } returns firstResponse
        every { converter2.convert(any(), any()) } returns secondResponse
        every { converter1.supports(any(), any()) } returns false
        every { converter2.supports(any(), any()) } returns true

        // execution
        val result = PathConverters.convert(randomString, startPoint)

        // validation
        assertEquals(secondResponse, result)
    }

    @Test
    fun `convert should return the value generated by the converter with the higher priority when multiple supports the conversion scenario`() {
        // scenario
        val firstResponse = randomString
        val secondResponse = randomString
        every { converter1.convert(any(), any()) } returns firstResponse
        every { converter2.convert(any(), any()) } returns secondResponse
        every { converter1.supports(any(), any()) } returns true
        every { converter2.supports(any(), any()) } returns true

        // execution
        val result = PathConverters.convert(randomString, startPoint)

        // validation
        assertEquals(firstResponse, result)
    }

    private fun buildMockedConverter(
        converterPriority: Int,
        enabled: Boolean = false,
        response: String = randomString,
    ) = mockk<PathConverter> {
        every { priority } returns converterPriority
        every { supports(any(), any()) } returns enabled
        every { convert(any(), any()) } returns response
    }
}
